use super::{Key, Value};

pub keyvalues -> Value
    = kv:keyvalue* { Value::from(kv) }

pub object -> Value
    = "{" wsnl kvs:keyvalue* wsnl "}" {
        Value::from(kvs)
    }

pub keyvalue -> (Key, Value)
    = keyvalue1 / keyobject

keyvalue1 -> (Key, Value)
    = wsnl k:key ws "=" ws v:value ";" wsnl { (Key::from(k), v) }

pub keyobject -> (Key, Value)
    = wsnl keys:multiKey+ "="? ws v:object wsnl { (Key::from(keys), v) }

multiKey -> String
    = k:key (whitespace+ / &[={]) { k }

jsonKeyValue -> (String, Value)
    = k:doubleQuotedString ws ":" ws v:jsonValue { (k, v) }

pub key -> String
    = doubleQuotedString / rawKeyString

pub value -> Value
    = number / time / float / boolean / null / string

jsonValue -> Value
    = rawNumber / float / boolean / null / string

string -> Value
    = s:(doubleQuotedString / rawString) { Value::from(s) }

number -> Value
    = binaryPrefixedNumber / siPrefixedNumber / rawNumber

rawNumber -> Value
    = n:int !rawStringChar { Value::from(n) }

siPrefixedNumber -> Value
    = n:int unit:$([kKmMgG]) !rawStringChar {
        Value::from(match unit {
            "k" | "K" => n * 1_000,
            "m" | "M" => n * 1_000_000,
            "g" | "G" => n * 1_000_000_000,
            _ => panic!()
        })
    }

binaryPrefixedNumber -> Value
    = n:int unit:$([kKmMgG]) "b" !rawStringChar {
        Value::from(match unit {
            "k" | "K" => n * 1_024,
            "m" | "M" => n * 1_048_576,
            "g" | "G" => n * 1_073_741_824,
            _ => panic!()
        })
    }

float -> Value
    = n:decimal !rawStringChar { Value::from(n) }

time -> Value
    = n:decimal unit:$("ms" / "s" / "min" / "d" / "w" / "y") !rawStringChar {
        Value::from(match unit {
            "ms" => n / 1000f64,
            "s" => n,
            "min" => n * 60f64,
            "d" => n * 86_400f64,
            "w" => n * 604_800f64,
            "y" => n * 31_536_000f64,
            _ => panic!()
        })
    }

boolean -> Value
    = true / false

true -> Value
    = ("true" / "yes" / "on") !rawStringChar { Value::Boolean(true) }

false -> Value
    = ("false" / "no" / "off") !rawStringChar { Value::Boolean(false) }

null -> Value
    = "null" !rawStringChar { Value::Null }

int -> i64
    = n:$(digit+) !"." { n.parse().unwrap() }

decimal -> f64
    = n:$(digit+("." digit+)?) { n.parse().unwrap() }

word -> &'input str
    = s:$([a-zA-Z_][a-zA-Z0-9_]*) { s }

wsnl -> ()
    = [ \n]*

wsp -> ()
    = " "+

ws -> ()
    = " "*

rawKeyString -> String
    = s:(rawKeyChar / escapeSequence)+ { s.into_iter().collect() }

rawKeyChar -> char
    = !("=" / "\\" / whitespace / eol) c:$(.) { c.chars().next().unwrap() }

rawString -> String
    = s:(rawStringChar / escapeSequence)+ { s.into_iter().collect() }

rawStringChar -> char
    = !(";" / "\\" / whitespace / eol) c:$(.) { c.chars().next().unwrap() }

doubleQuotedString -> String
    = '"' s:doubleQuotedChar* '"' { s.into_iter().collect() }

doubleQuotedChar -> char
    = simpleDoubleQuotedChar / escapeSequence

simpleDoubleQuotedChar -> char
    = !('"' / "\\" / eol) c:$(.) { c.chars().next().unwrap() }

escapeSequence -> char
    = "\\" !(digit / eol) c:$(.) {
        match c.chars().next().unwrap() {
            'n' => '\n',
            'r' => '\r',
            't' => '\t',
            x => x
        }
    }

comment = singleLineComment / multiLineComment

singleLineComment = "#" (!eol .)*

multiLineComment = "/*" (!"*/" .)* "*/"

digit = [0-9]

eol = [\n\r\u{2028}\u{2029}]

whitespace = [ \t\u{00A0}\u{FEFF}\u{1680}\u{180E}\u{2000}-\u{200A}\u{202F}\u{205F}\u{3000}]
